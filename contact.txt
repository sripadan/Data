Data Contracts & Governance Design Document

1. Introduction

Modern data platforms need governance, auditability, and accountability between producers (who publish datasets) and consumers (who use them).
Contracts provide a formalized agreement that governs dataset ownership, quality, access, and obligations.

This document introduces the data contract model, explains its concepts, and provides a database design that supports auditability, consumer overrides, and runtime evidence.

â¸»

2. Core Concepts

Contracts (logical agreements)
	â€¢	A contract is a human/business-level agreement tied to one or more datasets.
	â€¢	It describes ownership, governance obligations, and recertification policies.
	â€¢	Contracts are lightweight metadata; detailed policies live in contract versions.

ðŸ‘‰ Why: Establishes accountability and provides a unit of negotiation between producer(s) and consumer(s).

â¸»

Contract Versions (immutable snapshots)
	â€¢	Each contract version captures a full snapshot of policies (schema, rules, SLAs, access policies).
	â€¢	Versions are immutable for audit purposes.
	â€¢	Each version has a hash for tamper detection and deduplication.

ðŸ‘‰ Why: Provides audit trail, ensures reproducibility, and prevents silent drift.

â¸»

Consumer Overrides
	â€¢	Consumers may create child contracts that override producer policies:
	â€¢	Add stricter quality rules
	â€¢	Change alerting
	â€¢	Restrict access
	â€¢	Consumer contracts are linked to producers using:
	â€¢	parent_contract_id (at contract level)
	â€¢	parent_contract_version_id (at version level, optional for auditability)

ðŸ‘‰ Why: Allows consumers to customize agreements without breaking producer guarantees.

â¸»

TDQ vs BDQ Rules
	â€¢	TDQ (Technical Data Quality): machine-checkable, technical checks (nulls, schema, ranges).
	â€¢	BDQ (Business Data Quality): business semantics (domain lists, referential integrity).
	â€¢	Stored separately, owned by different roles, executed with different engines.

ðŸ‘‰ Why: Separation of responsibilities between data engineers (TDQ) and business stewards (BDQ).

â¸»

Rules Executions (Results)
	â€¢	Store runtime evaluation of rules.
	â€¢	Captures status (PASS/FAIL/WARN), metrics, and sample errors.
	â€¢	Append-only; partitions/TTL recommended for scale.

ðŸ‘‰ Why: Provides telemetry and evidence of compliance/non-compliance.

â¸»

Subscriptions
	â€¢	A subscription links a consumer contract to a contract version (or latest active).
	â€¢	Supports explicit version pinning for auditability.
	â€¢	Ensures consumers are tied to contracts (not just IDs), which enables overrides.

ðŸ‘‰ Why: Makes consumer obligations explicit and prevents silent policy drift.

â¸»

Access vs Usage
	â€¢	Access (policy): versioned, describes allowed rights (read/export/write).
	â€¢	Usage (telemetry): high-volume operational logs, reconciled against access policies.

ðŸ‘‰ Why: Clear distinction between what should happen and what actually happened.

â¸»

Recovery Objectives (RTO/RPO)
	â€¢	Captured per contract version.
	â€¢	Define recovery time and recovery point objectives.
	â€¢	Drive alerts when violated.

ðŸ‘‰ Why: Operational SLAs for resilience.

â¸»

Alerts & Notifications
	â€¢	Policies for who gets notified when rules or SLAs fail.
	â€¢	Flexible recipient model (emails, Slack, PagerDuty, webhooks).

ðŸ‘‰ Why: Ensures violations trigger actionable responses.

â¸»

Recertification
	â€¢	Scheduled review of contracts to prevent stale policies.
	â€¢	Captured as governance workflow with timestamps.

ðŸ‘‰ Why: Ensures contracts evolve with regulations and business changes.


4. Effective Policy Resolution (Consumer Overrides)
	â€¢	Step 1: Find the subscribed consumer_contract_id in subscriptions.
	â€¢	Step 2: If contract_version_id is pinned â†’ use it. Otherwise â†’ resolve to latest active version.
	â€¢	Step 3: If consumer version has parent_contract_version_id â†’ load producer version rules.
	â€¢	Step 4: Merge producer + consumer rules:
	â€¢	Conflict â†’ consumer wins
	â€¢	Additions â†’ union
	â€¢	Access rights â†’ union/intersection (policy-driven)
	â€¢	Step 5: Apply merged policy at runtime.

â¸»

5. Governance Best Practices
	â€¢	Ownership:
	â€¢	TDQ â†’ Data Engineering
	â€¢	BDQ â†’ Business Stewards
	â€¢	RTO/RPO â†’ SRE/Operations
	â€¢	Auditability:
	â€¢	Keep all contract_versions immutable
	â€¢	Retain execution logs (summarize, archive raw)

